{"name":"Code Example - Iterator","tagline":"","body":"## Background\r\n\r\nThese are the early days of Twitter, and you are a new developer on the team.         \r\n\r\nLast week, your team realized that they can increase user engagement by recommending potential followees to users.\r\nSince we only have 500 users, we don't need anything fancy for this week, we just need to create a simple solution that will satisfy the following user stories: \r\n\r\n * As an employee, I want to manually add user A to user B’s potential followees, so that user B will be recommended to follow user A.\r\n * As an employee, I want to manually remove user A from user B’s potential followees, so that user B will no longer be recommended to follow user A.\r\n\r\n\r\n## Step 1\r\n\r\nYou start by creating \"the skeleton\":\r\n \r\n * A `User` class\r\n * A `Recommender` interface\r\n   * As our system evolves, we can use more sophisticated recommenders.\r\n * A `SimpleRecommender` class that implements the `Recommender` interface\r\n   * Methods are not implemented yet.\r\n * A few JUnit tests that test the most basic functionality of `SimpleRecommender`\r\n\r\nFor more details, [browse the source code on GitHub](https://github.com/csc301-fall-2015/iterator-lecture/tree/7bc8abbf0192f34f22ce6f988fc9c2a28fbd2503), or run `git checkout 7bc8abbf01` on your local clone.\r\n\r\n## Step 2\r\n\r\nNext, you implement the `SimpleRecommender`.          \r\n[browse the source code on GitHub](https://github.com/csc301-fall-2015/iterator-lecture/tree/1d217a09b2106b2dea8811aae7ebcaccb28eb6d4), or run `git checkout 1d217a09b` on your local clone.\r\n\r\nAt the point, your teammate joins you and reviews your code.\r\nShe notices a potential problem with your code ...\r\n\r\n## Step 3\r\n\r\nYour teammate decides to \"keep things interesting for our users\" - \r\nShe wants to display a (possibly) different recommendation every time the users uses the app.\r\n\r\nShe decides to write a quick script that:\r\n * Uses your `SimpleRecommender`\r\n * Sets up a user with 20 recommended potential followees\r\n * The script does the following a few times, in a loop:\r\n   * Get the recommended potential followees\r\n   * Shuffle the list\r\n   * Keep only the first 3 users\r\n\r\nYou can see the script [here](https://github.com/csc301-fall-2015/iterator-lecture/blob/d109bacdf4641d4025209d651628ac0069101fdf/src/test/java/QuickScript.java).\r\n\r\nThe script exposes a problem ... it accidentally messed up the SimpleRecommender's internal data structure.\r\n\r\n#### Fix 1\r\n\r\nYou fix the problem [by returning an unmodifiable list](https://github.com/csc301-fall-2015/iterator-lecture/commit/989ce2a1b53d7ba7685299e51c8904539fe8f5e0).\r\n\r\nBut, this change breaks our script, because the script wants to change the returned list.\r\n\r\n#### Fix 2\r\n\r\nOK, you fix the problem by [returning a copy of the list](https://github.com/csc301-fall-2015/iterator-lecture/commit/877decc40ee671f86a0c76ba9da9cc84393cce85).\r\n \r\n\r\n## Step 4\r\n\r\nYou talk to your colleague again, and she notices that your recommender is slightly inefficient in terms of memory use - Every time somebody asks for a recommendation, it creates a copy of a list.\r\n\r\nYour colleague reminds you about the [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) design pattern, which can be useful in our case.\r\n\r\nYou follow your colleague's advice and change the `Recommender` interface to use an iterator, instead of a list.\r\n\r\n[browse the source code on GitHub](https://github.com/csc301-fall-2015/iterator-lecture/tree/9d75fa559b8d656ebac64004fc21be85e2fa37ea), or run `git checkout 9d75fa559b` on your local clone.\r\n\r\nNext, you also update [the script](https://github.com/csc301-fall-2015/iterator-lecture/blob/e46658e733f26dd28b7f89c2eb940b85782c4713/src/test/java/QuickScript.java) (that selects an arbitrary subset of 3 potential followees) to use an iterator instead of a list.\r\n\r\n## Step 5\r\n\r\nWe start recommending potential followees using code similar to your script.\r\n\r\nAfter a while, we revisit the code and realize it's inefficient, in terms of memory use - \r\nIn order to recommend potential users, we:\r\n\r\n 1. Get an iterator of users from a recommender\r\n 2. Get all the users out of the iterator and into a list\r\n 3. Shuffle the list and keep only the first 3 users\r\n\r\nNow that our product is successful and has many users, this is becoming a problem ...\r\n * Our new recommenders return iterators with thousands of potential followees.\r\n * We create in-memory lists from all of these items, although we end up using only 3 users from each list.\r\n * These lists waste memory and kick-off garbage collection which impacts the performance of our system.\r\n\r\nYou team-lead asks you to fix it. To be a bit more formal, your task is:\r\n\r\n * Given an iterator with n items (where n is large), create an iterator with k items (where k is a small constant)\r\n   * The items should come from the underlying iterator\r\n   * The items should be chosen randomly (more or less)\r\n   * Use O(k) memory\r\n\r\nYou implement a new, slightly more sophisticated [filtering iterator](https://github.com/csc301-fall-2015/iterator-lecture/blob/27d642447c266d3fe68fd452a37da22cfcb8d462/src/main/java/edu/toronto/csc301/examples/FilteringIterator.java) that selects k \"random\" items from an underlying iterator.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}